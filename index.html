<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Garment NFT</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 900px; margin: auto; }
        pre { background-color: #f0f0f0; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; font-size: 12px; }
        .hidden { display: none; }
        button { padding: 8px 12px; font-size: 14px; cursor: pointer; margin-top: 5px; }
        input, textarea { width: 98%; padding: 8px; font-size: 14px; margin-top: 5px; }
        .section { margin-top: 20px; border-top: 1px solid #ccc; padding-top: 20px; }
        .nft-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-top: 15px; }
        .nft-card { border: 1px solid #ccc; border-radius: 8px; padding: 10px; text-align: center; }
        .nft-card img { width: 100%; height: 200px; object-fit: cover; border-radius: 4px; }
        .nft-card h4 { margin: 10px 0 5px 0; }
    </style>
</head>
<body>
    <h1>Garment NFT</h1>

    <!-- ë¡œê·¸ì¸ ì˜ì—­ -->
    <div id="login-section">
        <p>ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•˜ë ¤ë©´ ë¨¼ì € êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.</p>
        <button onclick="loginWithGoogle()">Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸</button>
    </div>

    <!-- ë©”ì¸ ì˜ì—­ -->
    <div id="main-section" class="hidden">
        <hr>
        <h2>ì¸ì¦ ìƒíƒœ:</h2>
        <pre id="auth-status">ë¡œê·¸ì¸ ëŒ€ê¸° ì¤‘...</pre>
        
        <!-- í”„ë¡œí•„ ê´€ë¦¬ -->
        <div class="section">
            <h2>í”„ë¡œí•„ ê´€ë¦¬</h2>
            <label for="nickname-input">ë‹‰ë„¤ì„:</label>
            <input type="text" id="nickname-input" placeholder="ìƒˆë¡œìš´ ë‹‰ë„¤ì„ ì…ë ¥">
            <label for="bio-input">ìê¸°ì†Œê°œ:</label>
            <textarea id="bio-input" rows="3" placeholder="ìê¸°ì†Œê°œ ì…ë ¥ (ì„ íƒ)"></textarea>
            <button onclick="updateProfile()">í”„ë¡œí•„ ì €ì¥í•˜ê¸°</button>
            <pre id="profile-status">í”„ë¡œí•„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</pre>

            <a href="/mint.html">
                <button style="margin-top: 15px; background-color: #4CAF50; color: white;">
                    ë””ìì¸ ìƒì„±í•˜ê¸°
                </button>
            </a>
        </div>

        <!-- ì§€ê°‘ ì—°ë™ -->
        <div class="section">
            <h2>ì§€ê°‘ ì—°ë™</h2>
            <p>MetaMask ì§€ê°‘ì„ ê³„ì •ì— ì—°ê²°í•˜ì„¸ìš”.</p>
            <button onclick="linkWallet()">MetaMask ì§€ê°‘ ì—°ê²°í•˜ê¸°</button>
            <pre id="wallet-status">ì—°ê²° ëŒ€ê¸° ì¤‘...</pre>
        </div>

        <!-- ë‚´ê°€ ë§Œë“  NFT -->
        <div class="section">
            <h3>ë‚´ê°€ ë§Œë“  NFT</h3>
            <div id="created-nfts-grid" class="nft-grid"></div>
        </div>

        <!-- ë‚´ê°€ ì†Œìœ í•œ NFT -->
        <div class="section">
            <h3>ë‚´ê°€ ì†Œìœ í•œ NFT</h3>
            <div id="collected-nfts-grid" class="nft-grid"></div>
        </div>
        
        <!-- ê±°ë˜ ë‚´ì—­ -->
        <div class="section">
            <h3>ë‚´ ê±°ë˜ ë‚´ì—­</h3>
            <pre id="transactions-result">ê±°ë˜ ë‚´ì—­ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</pre>
        </div>

        <!-- NFT ìƒì„¸ ì¡°íšŒ -->
        <div class="section">
            <h3>NFT ìƒì„¸ ì¡°íšŒ</h3>
            <input type="text" id="nft-id-input" placeholder="NFT ID ì…ë ¥">
            <button onclick="getNftDetail()">NFT ìƒì„¸ ì¡°íšŒ</button>
            <pre id="nft-detail-result">ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</pre>
        </div>

        <button onclick="logout()">ë¡œê·¸ì•„ì›ƒ</button>
    </div>

         
    <script>
        const SUPABASE_URL = 'https://ssjamldabxxymustdcaw.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNzamFtbGRhYnh4eW11c3RkY2F3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyODU5ODcsImV4cCI6MjA2OTg2MTk4N30.guuVLX2yI-WC9jVTKh9fzfK78so5kdsd9GJ6CqUP_Iw'; // ğŸš¨ ë°˜ë“œì‹œ ë³¸ì¸ì˜ anon í‚¤ë¡œ ë³€ê²½í•´ì£¼ì„¸ìš”!
        const BACKEND_URL = 'http://localhost:5050';

        const { createClient } = supabase;
        const mySupabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const loginSection = document.getElementById('login-section');
        const mainSection = document.getElementById('main-section');
        const authStatus = document.getElementById('auth-status');
        const profileStatus = document.getElementById('profile-status');
        const walletStatus = document.getElementById('wallet-status');
        const nicknameInput = document.getElementById('nickname-input');
        const bioInput = document.getElementById('bio-input');
        const createdNftsGrid = document.getElementById('created-nfts-grid');
        const collectedNftsGrid = document.getElementById('collected-nfts-grid');
        const transactionsResult = document.getElementById('transactions-result');

        let accessToken = null;

        // êµ¬ê¸€ ë¡œê·¸ì¸
        async function loginWithGoogle() {
            await mySupabaseClient.auth.signInWithOAuth({
                provider: 'google',
                options: { redirectTo: window.location.href }
            });
        }
        async function logout() {
            await mySupabaseClient.auth.signOut();
        }

        // í”„ë¡œí•„ ë¶ˆëŸ¬ì˜¤ê¸°
        async function getProfile() {
            try {
                const res = await fetch(`${BACKEND_URL}/api/users/me`, {
                    headers: { 'Authorization': `Bearer ${accessToken}` }
                });
                if (!res.ok) throw new Error('í”„ë¡œí•„ ì •ë³´ ë¡œë”© ì‹¤íŒ¨');
                const profile = await res.json();
                nicknameInput.value = profile.public_username || '';
                bioInput.value = profile.bio || '';
                profileStatus.textContent = 'í”„ë¡œí•„ ë¡œë“œ ì™„ë£Œ';
            } catch (err) {
                profileStatus.textContent = `ì˜¤ë¥˜: ${err.message}`;
            }
        }

        // í”„ë¡œí•„ ì—…ë°ì´íŠ¸
        async function updateProfile() {
            profileStatus.textContent = 'í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì¤‘...';
            try {
                const res = await fetch(`${BACKEND_URL}/api/users/me/profile`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: JSON.stringify({
                        nickname: nicknameInput.value,
                        bio: bioInput.value
                    })
                });
                const result = await res.json();
                if (!res.ok) throw new Error(result.message || 'ì—…ë°ì´íŠ¸ ì‹¤íŒ¨');
                profileStatus.textContent = 'í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì™„ë£Œ';
                await getProfile();
            } catch (err) {
                profileStatus.textContent = `ì˜¤ë¥˜: ${err.message}`;
            }
        }

        // ì§€ê°‘ ì—°ë™
        async function linkWallet() {
            walletStatus.textContent = 'ì§€ê°‘ ì—°ê²° ì‹œì‘...';
            try {
                const nonceRes = await fetch(`${BACKEND_URL}/api/users/me/wallets/nonce`, {
                    headers: { 'Authorization': `Bearer ${accessToken}` }
                });
                if (!nonceRes.ok) throw new Error('Nonce ìš”ì²­ ì‹¤íŒ¨');
                const { nonce } = await nonceRes.json();
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const walletAddress = accounts[0];
                const signature = await window.ethereum.request({
                    method: 'personal_sign',
                    params: [nonce, walletAddress]
                });
                const linkRes = await fetch(`${BACKEND_URL}/api/users/me/wallets`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: JSON.stringify({ address: walletAddress, signature })
                });
                const result = await linkRes.json();
                if (!linkRes.ok) throw new Error(result.message || 'ì§€ê°‘ ì—°ë™ ì‹¤íŒ¨');
                walletStatus.textContent = `ì„±ê³µ! ì§€ê°‘ ì£¼ì†Œ: ${result.wallet.address}`;
            } catch (err) {
                walletStatus.textContent = `ì˜¤ë¥˜: ${err.message}`;
            }
        }

        // NFT ë Œë”ë§
        function renderNfts(container, nfts) {
            container.innerHTML = '';
            if (!nfts || nfts.length === 0) {
                container.innerHTML = '<p>í•´ë‹¹ NFTê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }
            nfts.forEach(nft => {
                const card = document.createElement('div');
                card.className = 'nft-card';
                card.innerHTML = `
                    <img src="${nft.image_url || 'https://via.placeholder.com/200'}" alt="${nft.name}">
                    <h4>${nft.name}</h4>
                    
                `;
                container.appendChild(card);
            });
        }

        // ë§ˆì´í˜ì´ì§€ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        async function fetchMyPageData() {
            try {
                const [profileRes, createdRes, collectedRes, txRes] = await Promise.all([
                    fetch(`${BACKEND_URL}/api/users/me`, { headers: { 'Authorization': `Bearer ${accessToken}` } }),
                    fetch(`${BACKEND_URL}/api/users/me/nfts?type=created`, { headers: { 'Authorization': `Bearer ${accessToken}` } }),
                    fetch(`${BACKEND_URL}/api/users/me/nfts?type=collected`, { headers: { 'Authorization': `Bearer ${accessToken}` } }),
                    fetch(`${BACKEND_URL}/api/users/me/transactions`, { headers: { 'Authorization': `Bearer ${accessToken}` } })
                ]);
                if (profileRes.ok) {
                    const data = await profileRes.json();
                    profileStatus.textContent = `ë‹‰ë„¤ì„: ${data.public_username}\nìê¸°ì†Œê°œ: ${data.bio || ''}`;
                }
                if (createdRes.ok) {
                    const data = await createdRes.json();
                    renderNfts(createdNftsGrid, data.nfts);
                }
                if (collectedRes.ok) {
                    const data = await collectedRes.json();
                    renderNfts(collectedNftsGrid, data.nfts);
                }
                if (txRes.ok) {
                    const data = await txRes.json();
                    transactionsResult.textContent = JSON.stringify(data, null, 2);
                }
            } catch (err) {
                console.error(err);
            }
        }
        // NFT ìƒì„¸ ì¡°íšŒ
        async function getNftDetail() {
            if (!accessToken) { 
                alert('ë¨¼ì € ë¡œê·¸ì¸í•˜ì„¸ìš”.'); 
                return; 
            }
            const nftId = document.getElementById('nft-id-input').value.trim();
            if (!nftId) {
                alert('NFT IDë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }
            const resultEl = document.getElementById('nft-detail-result');
            resultEl.textContent = 'ì¡°íšŒ ì¤‘...';
            try {
                const res = await fetch(`${BACKEND_URL}/api/nfts/${nftId}`, {
                    headers: { 'Authorization': `Bearer ${accessToken}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.message || 'ì¡°íšŒ ì‹¤íŒ¨');
                resultEl.textContent = JSON.stringify(data, null, 2);
            } catch (err) {
                resultEl.textContent = `ì˜¤ë¥˜: ${err.message}`;
            }
        }

        // ì¸ì¦ ìƒíƒœ ê°ì§€
        mySupabaseClient.auth.onAuthStateChange(async (event, session) => {
            if (event === 'SIGNED_IN' && session) {
                accessToken = session.access_token;
                loginSection.classList.add('hidden');
                mainSection.classList.remove('hidden');
                authStatus.textContent = 'ë¡œê·¸ì¸ ì„±ê³µ';
                await getProfile();
                await fetchMyPageData();
            } else if (event === 'SIGNED_OUT') {
                accessToken = null;
                loginSection.classList.remove('hidden');
                mainSection.classList.add('hidden');
            }
        });
    </script>
</body>
</html>
